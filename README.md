# graph-library
ЗВІТ
Розподіл роботи та написані алгоритми:
1. Настя Квасовець
Читання графу з файлу - функція яка вміє прочитати файл і записати дані в відповідну структуру. Формат файлу - csv, перша колонка містить перші вершини кожного ребра, друга - другі вершини (порядок вершин не грає ролі в випадку неорієнтованого графу, і є важливим коли граф орієнтований).

Читання графу з файлу - функція яка вміє прочитати файл і записати дані в відповідну структуру. Формат файлу - csv, перша колонка містить перші вершини кожного ребра, друга - другі вершини (порядок вершин не грає ролі в випадку неорієнтованого графу, і є важливим коли граф орієнтований).

На основі вмісту файлу функція будує:
список суміжності (словник, де кожній вершині відповідає множина сусідів);
множину ребер (пари вершин).

Це дозволяє легко працювати з графами в програмі: аналізувати зв’язність, знаходити шляхи, компоненти тощо.

Вхідні параметри:
filename: str -> Шлях до CSV-файлу. Кожен рядок повинен мати вигляд NodeA,NodeB.
oriented: bool -> Визначає тип графа. Якщо True – граф орієнтований; якщо False – неорієнтований (за замовчуванням).

Функція повертає кортеж:
(connections, edges)
де:
connections: dict[str, set[str]] — список суміжності;
edges: set[tuple[str, str]] — множина ребер у вигляді кортежів (source, destination).
Для неорієнтованого графа кожне ребро додається в обох напрямках.

Алгоритм роботи
Ініціалізація структур даних:
connections = {}
edges = set()

Зчитування рядків файлу з кодуванням UTF-8.

Обробка кожного рядка:
Видалення пробілів (strip()).
Розділення за комою (split(',')).
Перевірка, що в рядку рівно два вузли. Якщо ні — пропуск.

Додавання ребра (NodeA → NodeB):
оновлення connections;
додавання кортежу у edges.

Якщо граф неорієнтований (oriented == False):
додавання зворотного зв’язку (NodeB → NodeA);
додавання відповідного ребра в множину.

Повернення заповнених структур.

Перевірка коректності обробки рядків

Функція ігнорує:
порожні рядки;
рядки з неправильним форматом (не 2 значення);
рядки з зайвими комами.

Це робить функцію стійкішою до помилок у файлі.

Переваги реалізації:
Підтримка орієнтованих і неорієнтованих графів.
Автоматичний захист від некоректних рядків.
Ефективні структури даних (set, dict).
Проста інтеграція в більші проєкти.


2. Остап Сухомлин
Функція приймає граф та повертає Гамільтоновий цикл (чи повідомлення про його відсутність) у формі списку вершин.


3. Марія-Дарина Загарюк
Функція приймає граф та повертає Ейлерів цикл (чи повідомлення про його відсутність) у формі списку вершин.

Реалізація:
функція find_euler_cycle(graph, orientated)
Визначення: Ейлерів цикл — це замкнений шлях у графі, який проходить через кожне ребро рівно один раз і повертається у початкову вершину.
Критерії існування (Теорема Ейлера-Гіргольцера): 1) граф зв'язний (усі ребра належать одній компоненті зв'язності); 2) для орієнтованого: вхідний степінь == вихідний степінь; для неорієнтованого: степінь кожної вершини парний.
Якщо ці умови не виконуються, функція повертає None.

Побудова Ейлерового циклу: обрано **алгоритм Гіргольцера**.
Чому саме цей алгоритм?
Він є ефективнішим за алгоритм Флері, адже його часова складність складає $O(E)$, де E — кількість ребер.

Детальніше про перевагу алгоритму Гіргольцера:
На відміну від алгоритму Флері, який на кожному кроці вимагає перевірки ребра на те, чи є воно "мостом" (що потребує запуску алгоритму пошуку в ширину/вглиб і збільшує часову складність до O(E^2)), алгоритм Гіргольцера не виконує попередніх перевірок. Ефективність O(E) досягається завдяки тому, що:
Кожне ребро графа розглядається та додається до стека рівно один раз.
Кожне ребро видаляється з графа рівно один раз.
Це робить алгоритм Гіргольцера лінійним відносно кількості ребер, що дозволяє використовувати його для побудови циклів у графах з сотнями тисяч ребер за частки секунди.

Детальніше про роботу алгоритму Гіргольцера:
Алгоритм реалізовано ітеративним методом з використанням стека LIFO.
Алгоритм будує Ейлерів цикл, поступово знаходячи та об'єднуючи підцикли. Він використовує стек для відстеження поточного шляху та список для запису результату.

Основні кроки:
Рух вперед (DFS): Починаємо зі стартової вершини. Рухаємося по ребрах вглиб, додаючи вершини у stack і одразу видаляючи пройдені ребра з графа.

Крок назад: Якщо в поточної вершини немає доступних ребер (зайшли в глухий кут), переносимо її зі stack у фінальний список circuit. Це означає, що всі шляхи з цієї точки вже пройдені.

Циклічність і фінал: Повторюємо процес, доки стек не спорожніє. Отриманий список circuit перевертаємо, щоб отримати правильний порядок обходу.


4. Аліна Яцко
Функція приймає граф та перевіряє чи є він дводольним. Повертає булеве значення.
Функція приймає зв’язний граф і повертає його розфарбування у три кольори чи повідомлення про неможливість такого розфарбування. Повинна повертати список пар вершина - колір.

Функція is_bipartite перевіряє, чи є неорієнтований граф двочастковим (біпартитним). Вона використовує алгоритм пошуку в ширину (BFS) з розфарбовуванням, присвоюючи суміжним вершинам по черзі два різні "кольори" ('A' і 'B'). Якщо в процесі розфарбовування виявляється, що дві суміжні вершини мають або повинні мати однаковий колір, граф не є двочастковим і функція повертає False. Якщо вдається розфарбувати весь граф двома кольорами без конфліктів, вона повертає True, підтримуючи коректне розфарбовування для незв'язних компонентів графа.

Функція three_coloring намагається розфарбувати неорієнтований граф, використовуючи максимум три кольори ('A', 'B', 'C') таким чином, щоб жодні дві суміжні вершини не мали однакового кольору. Вона реалізує алгоритм пошуку в глибину (DFS) з відходженням назад. Функція рекурсивно перебирає доступні кольори для кожної вершини. Якщо поточне присвоєння кольору призводить до конфлікту або не дозволяє успішно розфарбувати решту графа, вона скасовує це присвоєння і пробує наступний колір. Якщо знайдено повне та дійсне розфарбування, вона повертає словник з присвоєними кольорами; якщо повне розфарбування трьома кольорами неможливе, повертається рядок 'Impossible to paint'.


5. Софія Вольвач
Функція приймає два графи і перевіряє чи є вони ізоморфними. Повертає булеве значення.


Враження і фідбек:
Назар найкращий ментор!!
